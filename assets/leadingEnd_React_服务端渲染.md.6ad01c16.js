import{_ as s,o as a,c as e,Q as n}from"./chunks/framework.b5309610.js";const u=JSON.parse('{"title":"服务端渲染","description":"","frontmatter":{},"headers":[],"relativePath":"leadingEnd/React/服务端渲染.md","filePath":"leadingEnd/React/服务端渲染.md","lastUpdated":null}'),l={name:"leadingEnd/React/服务端渲染.md"},o=n(`<h1 id="服务端渲染" tabindex="-1">服务端渲染 <a class="header-anchor" href="#服务端渲染" aria-label="Permalink to &quot;服务端渲染&quot;">​</a></h1><h2 id="一、csr与ssr" tabindex="-1">一、CSR与SSR <a class="header-anchor" href="#一、csr与ssr" aria-label="Permalink to &quot;一、CSR与SSR&quot;">​</a></h2><p><img src="https://raw.githubusercontent.com/caolinchao2/blogimg/main/img/image-20240705182052198.png" alt="image-20240705182052198"></p><ol><li>CSR：客户端渲染（Client Side Render） 过程：</li></ol><ul><li>①浏览器发送请求</li><li>②服务器返回空白HTML(HTML里包含一个root节点和js文件)</li><li>③浏览器下载js文件</li><li>④浏览器运行react代码</li><li>⑤页面准备就绪</li></ul><p>即：当前页面是由js文件渲染出来的；</p><p>SEO (搜索引擎优化)，搜索关键词的时候排名，对大多数搜索引擎，不识别JavaScript 内容，只识别 HTML 内容。 （注：原则上可以不用服务端渲染时最好不用，所以如果只有 SEO 要求，可以用预渲染等技术去替代；</p><ol start="2"><li>SSR：服务端渲染（Server Side Render） 过程：</li></ol><ul><li>浏览器发送请求</li><li>服务器运行react代码生成页面并返回HTML页面</li><li>浏览器下载HTML文档</li><li>页面准备就绪</li></ul><p>即：当前页面是由服务器生成好给到浏览器的；</p><h2 id="二、reactdomserver类库" tabindex="-1">二、ReactDOMServer类库 <a class="header-anchor" href="#二、reactdomserver类库" aria-label="Permalink to &quot;二、ReactDOMServer类库&quot;">​</a></h2><p>react-dom/server包提供了组件的服端渲染功能，返回值是一个html</p><ol><li>渲染为html：renderToString</li></ol><div class="language-jsx vp-adaptive-theme line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang">jsx</span><pre class="shiki github-dark vp-code-dark"><code><span class="line"><span style="color:#E1E4E8;">ReactDOMServer.</span><span style="color:#B392F0;">renderToString</span><span style="color:#E1E4E8;">(element);</span></span></code></pre><pre class="shiki github-light vp-code-light"><code><span class="line"><span style="color:#24292E;">ReactDOMServer.</span><span style="color:#6F42C1;">renderToString</span><span style="color:#24292E;">(element);</span></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br></div></div><ol start="2"><li>渲染为静态HTML：renderToStaticMarkup 该方法与renderToString方法类似，但这个方法不会生成额外的DOM特性，如：data-react-id等 React内部所使用的特性。当你想使用一个简单的静态页面生成器时这个方法非常有用，它会剥离额外的特性且会节省大量字节。</li></ol><div class="language-jsx vp-adaptive-theme line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang">jsx</span><pre class="shiki github-dark vp-code-dark"><code><span class="line"><span style="color:#E1E4E8;">ReactDOMServer.</span><span style="color:#B392F0;">renderToStaticMarkup</span><span style="color:#E1E4E8;">(element)</span></span></code></pre><pre class="shiki github-light vp-code-light"><code><span class="line"><span style="color:#24292E;">ReactDOMServer.</span><span style="color:#6F42C1;">renderToStaticMarkup</span><span style="color:#24292E;">(element)</span></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br></div></div><p>简单用法：在页面没有展示时，渲染的是该html，给页面添加骨架屏</p><div class="language-jsx vp-adaptive-theme line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang">jsx</span><pre class="shiki github-dark vp-code-dark"><code><span class="line"><span style="color:#F97583;">var</span><span style="color:#E1E4E8;"> html </span><span style="color:#F97583;">=</span><span style="color:#E1E4E8;"> ReactDOMServer.</span><span style="color:#B392F0;">renderToStaticMarkup</span><span style="color:#E1E4E8;">(</span></span>
<span class="line"><span style="color:#E1E4E8;">    &lt;</span><span style="color:#85E89D;">skeleton</span><span style="color:#E1E4E8;">/&gt;</span></span>
<span class="line"><span style="color:#E1E4E8;">)</span></span>
<span class="line"><span style="color:#E1E4E8;">document.</span><span style="color:#B392F0;">getElementById</span><span style="color:#E1E4E8;">(</span><span style="color:#9ECBFF;">&#39;root&#39;</span><span style="color:#E1E4E8;">).innerHTML </span><span style="color:#F97583;">=</span><span style="color:#E1E4E8;"> html</span></span>
<span class="line"><span style="color:#E1E4E8;">ReactDOM.</span><span style="color:#B392F0;">render</span><span style="color:#E1E4E8;">(&lt;</span><span style="color:#79B8FF;">App</span><span style="color:#E1E4E8;"> /&gt;, window.root) </span><span style="color:#6A737D;">// window.root相当于上面的获取id为root的</span></span></code></pre><pre class="shiki github-light vp-code-light"><code><span class="line"><span style="color:#D73A49;">var</span><span style="color:#24292E;"> html </span><span style="color:#D73A49;">=</span><span style="color:#24292E;"> ReactDOMServer.</span><span style="color:#6F42C1;">renderToStaticMarkup</span><span style="color:#24292E;">(</span></span>
<span class="line"><span style="color:#24292E;">    &lt;</span><span style="color:#22863A;">skeleton</span><span style="color:#24292E;">/&gt;</span></span>
<span class="line"><span style="color:#24292E;">)</span></span>
<span class="line"><span style="color:#24292E;">document.</span><span style="color:#6F42C1;">getElementById</span><span style="color:#24292E;">(</span><span style="color:#032F62;">&#39;root&#39;</span><span style="color:#24292E;">).innerHTML </span><span style="color:#D73A49;">=</span><span style="color:#24292E;"> html</span></span>
<span class="line"><span style="color:#24292E;">ReactDOM.</span><span style="color:#6F42C1;">render</span><span style="color:#24292E;">(&lt;</span><span style="color:#005CC5;">App</span><span style="color:#24292E;"> /&gt;, window.root) </span><span style="color:#6A737D;">// window.root相当于上面的获取id为root的</span></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br></div></div>`,18),p=[o];function r(t,c,i,d,E,y){return a(),e("div",null,p)}const h=s(l,[["render",r]]);export{u as __pageData,h as default};
