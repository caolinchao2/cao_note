import{_ as l,o as e,c as o,Q as i}from"./chunks/framework.b5309610.js";const f=JSON.parse('{"title":"","description":"","frontmatter":{},"headers":[],"relativePath":"面试相关/浏览器/1、跨标签页通讯.md","filePath":"面试相关/浏览器/1、跨标签页通讯.md","lastUpdated":1715053679000}'),a={name:"面试相关/浏览器/1、跨标签页通讯.md"},t=i('<h2 id="跨标签页通讯" tabindex="-1">跨标签页通讯 <a class="header-anchor" href="#跨标签页通讯" aria-label="Permalink to &quot;跨标签页通讯&quot;">​</a></h2><blockquote><p>不同标签页间的通讯，本质原理就是去运用一些可以 共享的中间介质，因此比较常用的有以下方法:</p></blockquote><ul><li><p>通过父页面<code>window.open()</code>和子页面<code>postMessage</code></p><ul><li>异步下，通过 <code>window.open(&#39;about: blank&#39;)</code> 和 <code>tab.location.href = &#39;*&#39;</code></li></ul></li><li><p>设置同域下共享的<code>localStorage</code>与监听<code>window.onstorage</code></p><ul><li>重复写入相同的值无法触发</li><li>会受到浏览器隐身模式等的限制</li></ul></li><li><p>设置共享<code>cookie</code>与不断轮询脏检查(<code>setInterval</code>)</p></li><li><p>借助服务端或者中间层实现</p></li></ul><h2 id="浏览器架构" tabindex="-1">浏览器架构 <a class="header-anchor" href="#浏览器架构" aria-label="Permalink to &quot;浏览器架构&quot;">​</a></h2><ul><li><p>用户界面</p></li><li><p>主进程</p></li><li><p>内核</p><ul><li><p>渲染引擎</p></li><li><p><code>JS</code>引擎</p><ul><li>执行栈</li></ul></li></ul></li><li><p>事件触发线程</p><ul><li>消息队列 <ul><li>微任务</li><li>宏任务</li></ul></li></ul></li><li><p>网络异步线程</p></li><li><p>定时器线程</p></li></ul>',5),c=[t];function d(p,_,n,r,s,u){return e(),o("div",null,c)}const m=l(a,[["render",d]]);export{f as __pageData,m as default};
