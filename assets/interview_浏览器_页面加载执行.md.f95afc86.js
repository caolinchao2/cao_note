import{_ as e,o,c as l,Q as c}from"./chunks/framework.b5309610.js";const C=JSON.parse('{"title":"页面加载执行","description":"","frontmatter":{},"headers":[],"relativePath":"interview/浏览器/页面加载执行.md","filePath":"interview/浏览器/页面加载执行.md","lastUpdated":null}'),i={name:"interview/浏览器/页面加载执行.md"},a=c('<h1 id="页面加载执行" tabindex="-1">页面加载执行 <a class="header-anchor" href="#页面加载执行" aria-label="Permalink to &quot;页面加载执行&quot;">​</a></h1><h3 id="浏览器事件循环" tabindex="-1">浏览器事件循环 <a class="header-anchor" href="#浏览器事件循环" aria-label="Permalink to &quot;浏览器事件循环&quot;">​</a></h3><blockquote><p>事件循环是指: 执行一个宏任务，然后执行清空微任务列表，循环再执行宏任务，再清微任务列表</p></blockquote><ul><li>微任务 <code>microtask(jobs): promise / process.nextTick / MutationObserver</code></li><li>宏任务 <code>macrotask(task): setTimout / setInterval / setImmediate / script / IO / UI Rendering</code></li></ul><blockquote><p>宏任务中包括了 <code>script</code> ，浏览器会先执行一个宏任务，接下来有异步代码的话就先执行微任务</p></blockquote><h3 id="怎么判断页面是否加载完成" tabindex="-1">怎么判断页面是否加载完成 <a class="header-anchor" href="#怎么判断页面是否加载完成" aria-label="Permalink to &quot;怎么判断页面是否加载完成&quot;">​</a></h3><ul><li><code>Load</code> 事件触发代表页面中的 <code>DOM</code>，<code>CSS</code>，<code>JS</code>，图片已经全部加载完毕。</li><li><code>DOMContentLoaded</code> 事件触发代表初始的 <code>HTML</code> 被完全加载和解析，不需要等待 <code>CSS</code>，<code>JS</code>，图片加载</li></ul><h3 id="css-加载会造成阻塞吗" tabindex="-1">css 加载会造成阻塞吗 ？ <a class="header-anchor" href="#css-加载会造成阻塞吗" aria-label="Permalink to &quot;css 加载会造成阻塞吗 ？&quot;">​</a></h3><ul><li><code>DOM</code> 和 <code>CSSOM</code> 通常是并行构建的,所以 CSS 加载不会阻塞 DOM 的解析。</li><li>然而,由于 <code>Render Tree</code> 是依赖于 DOM Tree 和 <code>CSSOM Tree</code> 的,</li><li>所以他必须等待到 <code>CSSOM Tree</code> 构建完成,也就是 CSS 资源加载完成(或者 CSS 资源加载失败)后,才能开始渲染。</li><li>因此,CSS 加载会阻塞 Dom 的渲染。</li><li>由于 JavaScript 是可操纵 DOM 和 css 样式的,如果在修改这些元素属性同时渲染界面（即 JavaScript 线程和 UI 线程同时运行）,那么渲染线程前后获得的元素数据就可能不一致了。</li><li>因此为了防止渲染出现不可预期的结果,浏览器设置 GUI 渲染线程与 JavaScript 引擎为互斥的关系。因此,样式表会在后面的 js 执行前先加载执行完毕,所以 css 会阻塞后面 js 的执行</li></ul><h3 id="为什么-js-阻塞页面加载" tabindex="-1">为什么 JS 阻塞页面加载 ? <a class="header-anchor" href="#为什么-js-阻塞页面加载" aria-label="Permalink to &quot;为什么 JS 阻塞页面加载 ?&quot;">​</a></h3><ul><li>由于 JavaScript 是可操纵 DOM 的,如果在修改这些元素属性同时渲染界面（即 JavaScript 线程和 UI 线程同时运行）,那么渲染线程前后获得的元素数据就可能不一致了</li><li>因此为了防止渲染出现不可预期的结果,浏览器设置 GUI 渲染线程与 JavaScript 引擎为互斥的关系</li><li>当 JavaScript 引擎执行时 GUI 线程会被挂起,GUI 更新会被保存在一个队列中等到引擎线程空闲时立即被执行</li><li>从上面我们可以推理出,由于 GUI 渲染线程与 JavaScript 执行线程是互斥的关系,</li><li>当浏览器在执行 JavaScript 程序的时候,GUI 渲染线程会被保存在一个队列中,直到 JS 程序执行完成,才会接着执行</li><li>因此如果 JS 执行的时间过长,这样就会造成页面的渲染不连贯,导致页面渲染加载阻塞的感觉</li></ul><h3 id="domcontentloaded-与-load-的区别" tabindex="-1">DOMContentLoaded 与 load 的区别 ? <a class="header-anchor" href="#domcontentloaded-与-load-的区别" aria-label="Permalink to &quot;DOMContentLoaded 与 load 的区别 ?&quot;">​</a></h3><ul><li>当 <code>DOMContentLoaded</code> 事件触发时,仅当 <code>DOM</code> 解析完成后,不包括样式表,图片。我们前面提到 CSS 加载会阻塞 Dom 的渲染和后面 js 的执行,js 会阻塞 Dom 解析,所以我们可以得到结论:</li><li>当文档中没有脚本时,浏览器解析完文档便能触发 <code>DOMContentLoaded</code> 事件。如果文档中包含脚本,则脚本会阻塞文档的解析,而脚本需要等 CSSOM 构建完成才能执行。在任何情况下,<code>DOMContentLoaded</code> 的触发不需要等待图片等其他资源加载完成</li><li>当 <code>onload</code> 事件触发时,页面上所有的 <code>DOM</code>,样式表,脚本,图片等资源已经加载完毕</li><li><code>DOMContentLoaded</code> -&gt; <code>load</code></li></ul><h3 id="什么是-crp-即关键渲染路径-如何优化" tabindex="-1">什么是 CRP,即关键渲染路径? 如何优化 <a class="header-anchor" href="#什么是-crp-即关键渲染路径-如何优化" aria-label="Permalink to &quot;什么是 CRP,即关键渲染路径? 如何优化&quot;">​</a></h3><blockquote><p>关键渲染路径是浏览器将 HTML CSS JavaScript 转换为在屏幕上呈现的像素内容所经历的一系列步骤。也就是我们上面说的<strong>浏览器渲染流程</strong>。</p></blockquote><p>为尽快完成首次渲染,我们需要最大限度减小以下三种可变因素:</p><ul><li>关键资源的数量: 可能阻止网页首次渲染的资源。</li><li>关键路径长度: 获取所有关键资源所需的往返次数或总时间。</li><li>关键字节: 实现网页首次渲染所需的总字节数,等同于所有关键资源传送文件大小的总和</li></ul><p><strong>1. 优化 DOM</strong></p><ul><li>删除不必要的代码和注释包括空格,尽量做到最小化文件。</li><li>可以利用 GZIP 压缩文件。</li><li>结合 HTTP 缓存文件</li></ul><p><strong>2. 优化 CSSOM</strong></p><blockquote><p>缩小、压缩以及缓存同样重要,对于 CSSOM 我们前面重点提过了它会阻止页面呈现,因此我们可以从这方面考虑去优化。</p></blockquote><ul><li>减少关键 CSS 元素数量</li><li>当我们声明样式表时,请密切关注媒体查询的类型,它们极大地影响了 CRP 的性能</li></ul><p><strong>3. 优化 JavaScript</strong></p><blockquote><p>当浏览器遇到 script 标记时,会阻止解析器继续操作,直到 CSSOM 构建完毕,JavaScript 才会运行并继续完成 DOM 构建过程。</p></blockquote><ul><li><code>async</code>: 当我们在 <code>script</code> 标记添加 <code>async</code> 属性以后,浏览器遇到这个 <code>script</code> 标记时会继续解析 DOM,同时脚本也不会被 <code>CSSOM</code> 阻止,即不会阻止 <code>CRP</code>。</li><li><code>defer</code>: 与 <code>async</code> 的区别在于,脚本需要等到文档解析后（ <code>DOMContentLoaded</code> 事件前）执行,而 <code>async</code> 允许脚本在文档解析时位于后台运行（两者下载的过程不会阻塞 <code>DOM</code>,但执行会）</li><li>当我们的脚本不会修改 <code>DOM</code> 或 <code>CSSOM</code> 时,推荐使用 async</li><li>预加载 —— <code>preload &amp; prefetch</code></li><li><code>DNS</code> 预解析 —— <code>dns-prefetch</code></li></ul><p><strong>总结</strong></p><ul><li>分析并用 关键资源数 关键字节数 关键路径长度 来描述我们的 <code>CRP</code></li><li>最小化关键资源数:消除它们（内联）、推迟它们的下载（<code>defer</code>）或者使它们异步解析（<code>async</code>）等</li><li>优化关键字节数（缩小、压缩）来减少下载时间 优化加载剩余关键资源的顺序:</li><li>让关键资源（<code>CSS</code>）尽早下载以减少 <code>CRP</code> 长度</li></ul><h3 id="线程和进程" tabindex="-1">线程和进程 <a class="header-anchor" href="#线程和进程" aria-label="Permalink to &quot;线程和进程&quot;">​</a></h3><blockquote><p>进程（process）和线程（thread）是操作系统的基本概念</p></blockquote><p>进程是 CPU 资源分配的最小单位（是能拥有资源和独立运行的最小单位）<br> 线程是 CPU 调度的最小单位（是建立在进程基础上的一次程序运行单位）<br></p><p><strong>一个进程就是一个程序的运行实例</strong>：启动一个程序时，操作系统会为该程序创建一块内存，用来存放代码、运行中的数据和一个执行任务的主线程，我们把这样的一个运行环境叫<strong>进程</strong></p><p><strong>线程是进程内的一个执行单元</strong>：线程是不能单独存在的，是依附于进程并由进程来启动和管理的</p><div class="tip custom-block"><p class="custom-block-title">进程和线程的关系特点</p><ul><li>进程是拥有资源的基本单位；线程是调度和分配的基本单位（是进程内的一个执行单元，也是进程内的可调度实体）</li><li>进程之间相互隔离，互不干扰</li><li>一个进程中可以并发执行多个线程</li><li>一个线程只能隶属于一个进程，而一个进程是可以拥有多个线程的（但至少有一个主线程）</li><li>同一进程的所有线程共享该进程的所有数据</li><li>进程中的任意一线程执行出错，都会导致整个进程的崩溃</li><li>当一个进程关闭之后，操作系统会回收进程所占用的内存</li></ul></div><h3 id="chrome-打开一个页面会有几个进程" tabindex="-1">Chrome 打开一个页面会有几个进程？ <a class="header-anchor" href="#chrome-打开一个页面会有几个进程" aria-label="Permalink to &quot;Chrome 打开一个页面会有几个进程？&quot;">​</a></h3><blockquote><p>最新的 Chrome 多进程架构图</p></blockquote><ul><li><strong>浏览器主进程</strong>：负责界面显示、用户交互、子进程管理，同时提供存储等功能</li><li><strong>渲染进程</strong>：负责将 <code>HTML</code> <code>CSS</code> 和 <code>JavaScript</code> 转换为用户可以与之交互的网页 <ul><li>排版引擎 Blink 和 JavaScript 引擎 V8 都是运行在该进程中</li><li>默认情况下 Chrome 会为每个 Tab 标签创建一个渲染进程</li><li>出于安全考虑渲染进程都是运行在沙箱模式下</li></ul></li><li><strong>GPU 进程</strong>：负责网页、Chrome 的 UI 界面的绘制</li><li><strong>网络进程</strong>：负责页面的网络资源加载（之前是作为一个模块运行在浏览器进程）</li><li><strong>插件进程</strong>：负责插件的运行（因为插件易崩溃所以需要通过插件进程来隔离，以保证插件崩溃不会对浏览器和页面造成影响）</li></ul><p><a href="https://time.geekbang.org/column/article/113513" target="_blank" rel="noreferrer">Chrome 架构：仅仅打开了 1 个页面，为什么有 4 个进程？—— 浏览器工作原理与实践</a></p>',37),t=[a];function d(r,s,n,p,u,S){return o(),l("div",null,t)}const m=e(i,[["render",d]]);export{C as __pageData,m as default};
