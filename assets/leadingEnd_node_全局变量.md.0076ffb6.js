import{_ as e,o,c,Q as d}from"./chunks/framework.b5309610.js";const _=JSON.parse('{"title":"Node.js 中的全局变量与相关概念","description":"","frontmatter":{},"headers":[],"relativePath":"leadingEnd/node/全局变量.md","filePath":"leadingEnd/node/全局变量.md","lastUpdated":1727086072000}'),l={name:"leadingEnd/node/全局变量.md"},i=d('<h1 id="node-js-中的全局变量与相关概念" tabindex="-1">Node.js 中的全局变量与相关概念 <a class="header-anchor" href="#node-js-中的全局变量与相关概念" aria-label="Permalink to &quot;Node.js 中的全局变量与相关概念&quot;">​</a></h1><h2 id="全局变量定义" tabindex="-1">全局变量定义 <a class="header-anchor" href="#全局变量定义" aria-label="Permalink to &quot;全局变量定义&quot;">​</a></h2><div class="tip custom-block"><p class="custom-block-title">在 Node.js 中定义全局变量</p><ul><li>在 Node.js 中可以使用<code>global</code>来定义全局变量。例如在<code>a.js</code>中定义<code>global.xxx = &#39;xxx&#39;</code>，当在<code>a.js</code>中<code>require(&#39;xxx.js&#39;)</code>时，<code>xxx.js</code>也能够访问到这个变量。</li><li>在不同的运行环境中，全局变量的容器有所不同。在浏览器环境中，全局变量都在<code>window</code>对象下；而在 Node.js 环境中是<code>global</code>对象。</li><li>ECMAScript 2020 出现了<code>globalThis</code>全局变量，它会根据环境自动切换。在 Node.js 环境中会自动切换成<code>global</code>，在浏览器环境中自动切换成<code>window</code>，这为跨环境编程提供了很大的方便。</li></ul></div><div class="tip custom-block"><p class="custom-block-title">其他全局 API</p><ul><li>由于 Node.js 中没有 DOM（文档对象模型）和 BOM（浏览器对象模型），除了这些 API 之外，其他的 ECMAScript API 基本都能使用。</li><li>例如<code>setTimeout</code>、<code>setInterval</code>、<code>Promise</code>、<code>Math</code>、<code>console</code>、<code>Date</code>、<code>fetch</code>（在 Node v18 中）等 API 都是可以正常使用的。</li></ul></div><h2 id="node-js-内置全局-api" tabindex="-1">Node.js 内置全局 API <a class="header-anchor" href="#node-js-内置全局-api" aria-label="Permalink to &quot;Node.js 内置全局 API&quot;">​</a></h2><div class="tip custom-block"><p class="custom-block-title"><code>__dirname</code>和<code>__filename</code></p><ul><li>这两个全局变量只能在 CommonJS（CJS）规范中使用，在 ES 模块（ESM）规范中没有这两个全局变量。</li><li><code>__dirname</code>：它表示当前模块所在目录的绝对路径。</li><li><code>__filename</code>：它表示当前模块文件的绝对路径，包括文件名和文件扩展名。</li></ul></div><div class="tip custom-block"><p class="custom-block-title"><code>process</code>对象</p><ul><li><strong><code>process.argv</code></strong>：这是一个包含命令行参数的数组。第一个元素是 Node.js 的执行路径，第二个元素是当前执行的 JavaScript 文件的路径，之后的元素是传递给脚本的命令行参数。</li><li><strong><code>p<wbr>rocess.env</code></strong>：这是一个包含当前环境变量的对象，可以通过它访问并操作环境变量。</li><li><strong><code>process.cwd()</code></strong>：这个方法返回当前工作目录的路径。</li><li><strong><code>process.on(event, listener)</code></strong>：用于注册事件监听器。例如可以使用它监听诸如<code>exit</code>、<code>uncaughtException</code>等事件，并在事件发生时执行相应的回调函数。</li><li><strong><code>process.exit([code])</code></strong>：用于退出当前的 Node.js 进程，可以提供一个可选的退出码作为参数。</li><li><strong><code>process.pid</code></strong>：这个属性返回当前进程的 PID（进程 ID）。</li><li>这只是<code>process</code>对象的一些常用属性和方法，还有其他许多属性和方法可用于监控进程、设置信号处理、发送 IPC 消息等。需要注意的是，<code>process</code>对象是一个全局对象，可以在任何模块中直接访问，无需导入或定义。</li></ul></div><div class="tip custom-block"><p class="custom-block-title"><code>Buffer</code>类</p><ul><li>创建<code>Buffer</code>实例 <ul><li><code>Buffer.alloc(size[, fill[, encoding]])</code>：创建一个指定大小的新的<code>Buffer</code>实例，初始内容为零。<code>fill</code>参数可用于填充缓冲区，<code>encoding</code>参数指定填充的字符编码。</li><li><code>Buffer.from(array)</code>：创建一个包含给定数组的<code>Buffer</code>实例。</li><li><code>Buffer.from(string[, encoding])</code>：创建一个包含给定字符串的<code>Buffer</code>实例。</li></ul></li><li>读取和写入数据 <ul><li><code>buffer[index]</code>：通过索引读取或写入<code>Buffer</code>实例中的特定字节。</li><li><code>buffer.length</code>：获取<code>Buffer</code>实例的字节长度。</li><li><code>buffer.toString([encoding[, start[, end]]])</code>：将<code>Buffer</code>实例转换为字符串。</li></ul></li><li>转换数据 <ul><li><code>buffer.toJSON()</code>：将<code>Buffer</code>实例转换为 JSON 对象。</li><li><code>buffer.slice([start[, end]])</code>：返回一个新的<code>Buffer</code>实例，其中包含原始<code>Buffer</code>实例的部分内容。</li></ul></li><li>其他方法 <ul><li><code>Buffer.isBuffer(obj)</code>：检查一个对象是否是<code>Buffer</code>实例。</li><li><code>Buffer.concat(list[, totalLength])</code>：将一组<code>Buffer</code>实例或字节数组连接起来形成一个新的<code>Buffer</code>实例。</li></ul></li><li>从 Node.js 6.0 版本开始，<code>Buffer</code>构造函数的使用已被弃用，推荐使用<code>Buffer.alloc()</code>、<code>Buffer.from()</code>等方法来创建<code>Buffer</code>实例。<code>Buffer</code>类在处理文件、网络通信、加密和解密等操作中非常有用，尤其是在需要处理二进制数据时。</li></ul></div><h2 id="补充" tabindex="-1">补充 <a class="header-anchor" href="#补充" aria-label="Permalink to &quot;补充&quot;">​</a></h2><ol><li>关于<code>global</code>对象的更多特性 <ul><li>在 Node.js 中，<code>global</code>对象包含了很多全局属性和方法。例如，<code>global.console</code>实际上就是我们在代码中直接使用的<code>console</code>对象，它提供了诸如<code>console.log()</code>、<code>console.error()</code>等方法用于日志输出。</li><li><code>global.setTimeout</code>和<code>global.setInterval</code>的底层实现与浏览器中的类似，但在 Node.js 中它们更多地与事件循环机制相关联，用于异步任务的调度。</li></ul></li><li><code>process</code>对象的深入 <ul><li><code>process.stdout</code>和<code>process.stderr</code>是<code>process</code>对象中的重要属性，它们分别表示标准输出流和标准错误流。例如，可以使用<code>process.stdout.write(&#39;Hello World\\n&#39;)</code>来向控制台输出信息，这与<code>console.log()</code>有所不同，<code>console.log()</code>在输出内容后会自动添加换行符并且对对象进行格式化输出，而<code>process.stdout.write()</code>只是简单地将内容输出到标准输出流。</li><li><code>process.nextTick(callback)</code>是一个非常特殊的方法，它将回调函数<code>callback</code>添加到下一个事件循环的微任务队列中。这在处理异步操作的顺序控制时非常有用，例如在确保某些异步操作在其他操作之前执行。</li></ul></li><li><code>Buffer</code>类在网络编程中的应用 <ul><li>在网络编程中，当处理 TCP 或 UDP 套接字的数据传输时，<code>Buffer</code>类经常被用来处理发送和接收的数据。例如，当从套接字接收数据时，数据通常以<code>Buffer</code>的形式存在，然后可以使用<code>Buffer</code>的方法对数据进行解析、处理，再转换为合适的格式进行业务逻辑处理。</li><li>在 HTTP 协议中，<code>Buffer</code>也可以用于处理请求和响应的头部信息以及正文内容。例如，当处理 POST 请求的正文数据时，如果数据是二进制格式（如文件上传），<code>Buffer</code>类可以有效地处理这些数据的读取、解析和存储。</li></ul></li></ol>',10),s=[i];function r(t,a,n,f,u,p){return o(),c("div",null,s)}const b=e(l,[["render",r]]);export{_ as __pageData,b as default};
